---
title: DFS/BFS 겉핥기
date: 2021-01-06 09:01:26
category: algorithm
draft: false
---

## 개요

![](./images/bfs_vs_dfs.gif)

BFS와 DFS는 트리나 그래프를 탐색하는 방법이다. 기본적인 작동과 차이점은 위 그림을 참고하면 된다. 구현에서 주의할 점은 어떤 노드를 방문했는지를 검사해야한다는 것.

### 인접 행렬, 인접 리스트

노드들이 연결된 정보를 담고 있는 자료 구조이다. 

**인접 행렬**

그래프의 연결 관계를 이차원 배열로 나타내는 방식.
ex) 0번과 1번이 연결되어있다면 adj_matrix[0][1] = 1, adj_matrix[1][0] = 1 으로 표현한다.

인접 행렬로 나타낼 경우에는 모든 노드사이의 관계를 표시해야 하기 떄문에 인접 리스트보다는 큰 메모리 공간을 차지한다. 그래프 G=(V, E) 일 때, 인접 행렬의 크기는 V^2 만큼 필요하다.

인접 행렬은 구현이 쉽고 노드 두개의 관계를 확인하고 싶을 때 O(1)의 시간 복잡도로 확인할 수 있는 장점이 있다. 하지만 단일 노드 하나에 연결된 모든 노드에 방문해보기 위해서는 하나의 노드에 연관된 모든 관계를 확인해야 하기 떄문에 O(V)만큼의 시간이 걸린다.

**인접 리스트**

이차원 배열로 나타내는 인접 행렬과 다르게 linked_list와 같은 자료 구조로 표현하는 방식이다. 그래프 G=(V,E) [V는 노드 수, E는 연결된 선의 수] 는 V개의 헤더 노드와 2E개의 연결 노드가 필요하다. 

인접 행렬과는 다르게 노드 두개(i, j)의 관계를 확인해보는 작업은 리스트의[i]에 해당하는 리스트를 돌면서 j가 있는지 확인해야 하기 떄문에 O(1)로 바로 찾을 수 있는 인접 행렬보다는 느리다. 그러나 모든 노드의 관계를 확인하는 작업에 있어서는 O(V^2)가 걸리는 인접 행렬과는 다르게 간선만을 표시하기 떄문에 간선의 수인 O(E)만큼의 시간 복잡도를 가진다.

위와 같은 차이점이 있으니 주어진 문제의 특성에 따라 다른 자료 구조를 갖추는 것이 좋겠다.

## BFS - Breㅎadth First Search

너비 우선 탐색이라고도 하며 현재 노드에 연결된 모든 점들을 탐색하고 이를 반복하는 것이 BFS이다. BFS는 Queue를 통해 구현할 수 있다.BFS는 두 노드 사이의 최단경로, 임의의 경로를 찾을 때 사용할 수 있다.

**수행 과정**

1. 루트 노드를 queue에 삽입하고 방문처리한다.
2. 큐에서 노드 하나를 꺼낸다.
3. 꺼낸 노드에 연결된 노드 중 방문하지 않은 노드를 큐에 삽입하고 방문 처리한다.
4. 2~3의 과정을 큐가 빌 때까지 반복한다.

```python
# 연결된 노드를 표시하는 인접 리스트
adj_list = [[1,2,3],[0,4,5],[0,6,7],[0,8,9],[1],[1,10],[2],[2],[3],[3],[5]]

def bfs():
  # node를 저장할 queue
  bfs_list = [0]
  # 방문 기록을 남길 list
  visit = [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
  print('visited : 0')

  while bfs_list:
    node = bfs_list.pop(0)
    for x in adj_list[node]:
      if visit[x]:
        continue
      bfs_list.insert(0, x)
      visit[x] = 1
      print('visited : ' + str(x))

```

위처럼 queue를 이용해 인접 리스트에 표시된 노드들을 전부 탐색하는 코드를 짤 수 있다.

## DFS - Depth First Search

깊이 우선 탐색이라고도 한다. 그래프를 탐색하면서 더이상 탐색할 수 없을 떄까지 탐색한 후에 돌아와 다른 경로를 찾으며 탐색하는 기법이다. BFS에서 Queue가 사용되었다면 _다시 돌아온다_ 는 특성상 DFS는 Stack 또는 재귀 함수를 사용한다.

**수행 과정**
1. 루트 노드를 stack에 push하고 방문 처리한다.
2. stack의 top에 있는 노드와 연결된 방문하지 않은 노드 하나를 stack에 push하고 방문 처리한다.
3. 더이상 방문할 수 있는 노드가 없다면 pop한다.
4. stack이 빌 때까지 2번을 반복한다.

```python
# 연결된 노드를 표시하는 인접 리스트
adj_list = [[1,2,3],[0,4,5],[0,6,7],[0,8,9],[1],[1,10],[2],[2],[3],[3],[5]]
visit = [0,0,0,0,0,0,0,0,0,0,0]

def dfs_recursive(v):
  if(visit[v]):
    return
  print('visited : ' + str(v))
  visit[v] = 1
  for x in adj_list[v]:
    dfs_recursive(x)

def dfs_stack():
  # root node에서 시작
  dfs_list = [0]

  while dfs_list:
    node = dfs_list.pop()
    visit[node] = 1
    print('visited : ' + str(node))
    for x in adj_list[node]:
      if visit[x]:
        continue
      dfs_list.append(x)
```

위와 같이 stack과 재귀함수로 구현할 수 있다. 


