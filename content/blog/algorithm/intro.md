---
title: 알고리즘 겉핥기
date: 2021-01-03 09:01:52
category: algorithm
draft: false
---

## 알고리즘 겉핥기 목표
1. 배웠던 내용을 다시 정리하면서 뇌에 저장하고 기록하기
2. 코드를 보고 수행시간을 비교할 수 있는 수준까지 도달하기
3. 수식과 친해지기

## 알고리즘이란 무엇인가
- 입력과 출력으로 명시된 요구조건을 토대로 해결 절차를 기술한 것
- 특정한 문제를 해결하기 위한 동작이 단계적으로 명시된 것
- 언젠가는 끝나야 한다.

## 내가 알고리즘을 통해 얻을 수 있는 것은 무엇인가?
- 잘 알려진(well-known), 특정한 문제를 효율적으로 풀기 위한 알고리즘 습득
- 체계적으로 생각하고 코드로 옮기는 훈련
- 지적 추상화를 지속적으로 반복하여 개발에 있어 멘탈 유지

## 바람직한 알고리즘이란 무엇일까?
- 명확하고 효율적이어야 한다.
- 가장 쉬운 것이 가장 좋은 것이다.
- 남이 봐도 알아볼 수 있어야 한다.
- 요구사항을 완벽히 충족할 수 있어야 한다.

## 점근적 표기법이란? - Asymptotic notations
- O(f(n))
  - big-O
  - f(n)의 비율과 같거나 낮은 정도로 시간 효율이 증가하는 함수
  - O(n), O(nlogn) ...
  - g(n) = O(f(n)) 이라고 할 떄, g는 f보다 빠르게 증가하지 않는다.
  - 상수 비율은 무시한다
  - O(n^2) = 3n^2 + 2 = 3n = nlogn + 5n ...
  - 하지만 위에서 3n, nlogn + 5n은 각각 O(n), O(nlogn) 이므로 굳이 O(n^2)으로 쓸 필요가 없다.
  - 가능한 최소한의 f(n)으로 표기하는 것이 원칙이다.
- Ω(f(n))
  - g(n) = Ω(f(n))일 때, g는 f보다 느리게 증가하지 않는다.(같거나 크다)
- Θ(f(n))
  - g(n) = Θ(f(n))일 때, g는 f와 같은 정도로 증가한다.

## 시간 복잡도의 분석
시간 복잡도를 분석할 때에는 크게 3가지의 종류로 구분한다.
1. Worst Case
    - 가장 최악의 효율을 보일 때의 input 값으로 산정하여 시간 복잡도를 계산하는 것 
2. Average Case
    - 모든 input을 분석하여 평균 값으로 시간복잡도를 계산하는 것
    - 분석하기 힘들다.
3. Best Case
    - 가장 빠른 경우의 input을 가정하여 시간 복잡도를 계산하는 것
